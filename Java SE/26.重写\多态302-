p302 重写 override


子类方法的名、返回、参数和父类一样
覆盖了父类的方法
package com.sean.override;

public class Animal {
    public void cry(){
        System.out.println("crying");
    }
}
public class Dog extends Animal{
    //dog是animal子类
    //dog的cry方法和animal的cry定义形式一样
    //dog的cry方法重写了animal的cry
    public void cry(){
        System.out.println("the dog is crying");
    }
}
public class Override01 {
    public static void main(String[] args) {
        //override
        Dog dog = new Dog();
        dog.cry(); //Dog中定义了cry方法，直接调用；若无，则向上查找Animal的cry
    }
}


p303 重写
1.方法名、形参列表必须完全一样
    Animal: public void cry(){}
    Dog:    public void cry(){}
2.子类返回类型要一样，或者是父类返回类型的子类
    Animal: public Object getInfo(){}
    Dog:    public String getInfo(){} 
        Object是String的父类，也构成重写
        若子类为Object，父类为String，则报错，不兼容
        
3.子类不能缩小父类的访问权限    public>protected>默认>private
    Animal: void sayOK(){}
    Dog:    public void syaOK(){} //OK
    Animal: void sayOK(){}
    Dog:    private void syaOK(){} //ERROR


p304 重载和重写

名称            范围     方法名      形参列表   返回类型        修饰符

重载overload    本类     必须一样    不能相同    无要求         无要求
重写override    子父类   必须一样    必须一样   相同或子类    子类不能缩小



p305
Person， private（name age） 构造器，say()
student,  private(score),id,  构造器，say()
main,  p1,s1,调用say

                package com.sean.override;

                public class OverrideExercise {
                    public static void main(String[] args) {
                        Person jack = new Person("jack", 10);
                        System.out.println(jack.say());
                        Student smith = new Student("smith", 10, 123456, 100);
                        System.out.println(smith.say());    }}

                public class Person {
                    private String name;
                    private int age;
                    public Person(String name, int age) {
                        this.name = name;
                        this.age = age;    }
                    public String say(){return "name= "+name+"age= "+age;}}、

                public class Student extends Person{
                    private int id;
                    private double score;
                    //父类没有默认构造器，子类需要显式定义构造器
                    public Student(String name, int age, int id, double score) {
                        super(name, age);
                        this.id = id;
                        this.score = score;
                    }
                    public String say(){
                        return super.say() + "id=" + id+"score="+score;
                    }
                    public int getId() {        return id;    }
                    public void setId(int id) {        this.id = id;    }
                    public double getScore() {        return score;    }
                    public void setScore(double score) {        this.score = score;    }
                }



p306 多态
master要给动物们（animal)喂食(food
传统方法解决：food{fish,bone,rice}
             master
             animal{dog,cat,pig}

Master:
  //给小猫 喂食 骨头
    public  void feed(Cat cat, Bone bone){
        System.out.println("master " + name + " feed " + cat.getName()
                +" with " + bone.getName());
    }
    //给小猫 喂食 鱼 方法重载
    public  void feed(Cat cat, Fish fish){
        System.out.println("master " + name + " feed " + cat.getName()
                +" with " + fish.getName());
    }
    需要不断地重载feed下去

main:
     Master tom = new Master("tom");
        
        Cat ca = new Cat("ca");
        Bone bo = new Bone("bo");
        tom.feed(ca,bo);
        Cat mic = new Cat("mic");
        Fish fi = new Fish("fi");
        tom.feed(mic,fi);


多态：提高代码复用性


p307 多态基本介绍

多态是指方法或对象有多种形态，建立在封装和继承的基础上

具体体现：
1.方法多态：
    重写和重载
    
    
p308  对象多态
对象的多态：
    1.一个对象的编译类型和运行类型可以不一致
        Animal animal = new Dog(); 【animal编译类是Animal，运行类是Dog】子类对象（dog可以赋给父类引用（animal
    2.编译类型由定义对象确定，不能改变
        Animal animal        Animal类的对象引用
    3.运行类型可以改变
        animal = new Cat();  指向Cat类的对象空间
    4.编译类型 = 运行类型
    
多态对程序的影响
        Animal animal = new Dog();
        animal.cry();   //执行到这里时 animal运行类型是dog，所以是dog的cry（）
        animal = new Cat();
        animal.cry();   //运行类型为Cat，Cat的cry()
        animal = new Fish();
        animal.cry();   //运行类型是Fish，Fish cannot cry
        
        
 p309 多态入门
 
 主人喂食问题：
 MAster：
    //使用多态机制，统一管理喂食
    //animal 可以指向Animal子类的对象
    //food 也可以指向Food子类的对象
    public void feed(Animal animal, Food food){
        System.out.println("master " + name + " feed " + animal.getName()
                +" with " + food.getName());
    }
 main:
        Master tom = new Master("tom");
        Cat ca = new Cat("ca");
        Bone bo = new Bone("bo");
        tom.feed(ca,bo);
        Cat mic = new Cat("mic");
        Fish fi = new Fish("fi");
        tom.feed(mic,fi);
        Pig pp = new Pig("pp");
        Rice rice = new Rice("rice");
        tom.feed(pp,rice);
 


p310 多态 向上转型
前提：类存在继承关系
向上转型：父类指向子类对象  
    父类 引用名 = new 子类
    Animal animal = new Cat();
特点：
1.可以调用父类所有成员（访问权限需要遵守），
2.不能调用子类特有成员
    animal可以调用Animal的方法（eat，run，。。
    但不能调用Cat的特有方法（抓老鼠。。
    
3.按照从子类（运行类型）到父类（遍历类型）的查找顺序


  
p311 多态 向下转型

子类类型 引用名 = （子类类型）父类引用
    Animal animal = new Dog();
    Dog dog = (Dog) animal;//此时有两个引用animal和dog同时指向new Dog对象
只能强转父类的引用，不能强转父类的对象
父类引用必须指向当前目标类型的对象
    Cat cat = (Cat) animal;// Class Exception 类异常
可以调用子类所有成员


p312 多态细节

1.属性不能重写，直接看编译类型
            package com.sean.poly;

            public class PolyDetail02 {
                public static void main(String[] args) {
                    Base base = new Sub();          //编译类型为Base
                    System.out.println(base.count); //直接使用Base属性count=10
                }
            }
            class Base{
                int count = 10;
            }
            class Sub extends Base{
                int count = 20;            //对象空间中存有两个值 10 20
            }

2.instanceof 比较操作符

    判断对象的运行类型是否为 XX类 或 XX的子类
                package com.sean.poly;

                public class PolyDetail03 {
                    public static void main(String[] args) {
                        BB bb = new BB();
                        System.out.println(bb instanceof BB);//true
                        System.out.println(bb instanceof AA);//true
                        AA aa = new BB();
                        System.out.println(aa instanceof BB);//true
                        System.out.println(aa instanceof AA);//true
                        AA Aa = new AA();
                        System.out.println(Aa instanceof BB);//false
                        System.out.println(aa instanceof AA);//true
                    }
                }
                class AA{}//父类
                class BB extends AA{}//子类



p313 多态练习
double d = 13.4;
long l = (long)d;
int in = 5;
boolean b = (boolean)in;//False int->boolean
Object obj = "Hello";//向上转型
String objStr = (String)obj;//向下转型

Object objPri = new Integer(5);
String str = (String) objOPri;//False 向下转型类型不符
Integer str1 = (Integer) objPri; //正确的向下转型



p314 多态练习














































