p302 重写 override


子类方法的名、返回、参数和父类一样
覆盖了父类的方法
package com.sean.override;

public class Animal {
    public void cry(){
        System.out.println("crying");
    }
}
public class Dog extends Animal{
    //dog是animal子类
    //dog的cry方法和animal的cry定义形式一样
    //dog的cry方法重写了animal的cry
    public void cry(){
        System.out.println("the dog is crying");
    }
}
public class Override01 {
    public static void main(String[] args) {
        //override
        Dog dog = new Dog();
        dog.cry(); //Dog中定义了cry方法，直接调用；若无，则向上查找Animal的cry
    }
}


p303 重写
1.方法名、形参列表必须完全一样
    Animal: public void cry(){}
    Dog:    public void cry(){}
2.子类返回类型要一样，或者是父类返回类型的子类
    Animal: public Object getInfo(){}
    Dog:    public String getInfo(){} 
        Object是String的父类，也构成重写
        若子类为Object，父类为String，则报错，不兼容
        
3.子类不能缩小父类的访问权限    public>protected>默认>private
    Animal: void sayOK(){}
    Dog:    public void syaOK(){} //OK
    Animal: void sayOK(){}
    Dog:    private void syaOK(){} //ERROR


p304 重载和重写

名称            范围     方法名      形参列表   返回类型        修饰符

重载overload    本类     必须一样    不能相同    无要求         无要求
重写override    子父类   必须一样    必须一样   相同或子类    子类不能缩小



p305
Person， private（name age） 构造器，say()
student,  private(score),id,  构造器，say()
main,  p1,s1,调用say

                package com.sean.override;

                public class OverrideExercise {
                    public static void main(String[] args) {
                        Person jack = new Person("jack", 10);
                        System.out.println(jack.say());
                        Student smith = new Student("smith", 10, 123456, 100);
                        System.out.println(smith.say());    }}

                public class Person {
                    private String name;
                    private int age;
                    public Person(String name, int age) {
                        this.name = name;
                        this.age = age;    }
                    public String say(){return "name= "+name+"age= "+age;}}、

                public class Student extends Person{
                    private int id;
                    private double score;
                    //父类没有默认构造器，子类需要显式定义构造器
                    public Student(String name, int age, int id, double score) {
                        super(name, age);
                        this.id = id;
                        this.score = score;
                    }
                    public String say(){
                        return super.say() + "id=" + id+"score="+score;
                    }
                    public int getId() {        return id;    }
                    public void setId(int id) {        this.id = id;    }
                    public double getScore() {        return score;    }
                    public void setScore(double score) {        this.score = score;    }
                }



p306 多态
master要给动物们（animal)喂食(food
传统方法解决：food{fish,bone,rice}
             master
             animal{dog,cat,pig}

Master:
  //给小猫 喂食 骨头
    public  void feed(Cat cat, Bone bone){
        System.out.println("master " + name + " feed " + cat.getName()
                +" with " + bone.getName());
    }
    //给小猫 喂食 鱼 方法重载
    public  void feed(Cat cat, Fish fish){
        System.out.println("master " + name + " feed " + cat.getName()
                +" with " + fish.getName());
    }
    需要不断地重载feed下去

main:
     Master tom = new Master("tom");
        
        Cat ca = new Cat("ca");
        Bone bo = new Bone("bo");
        tom.feed(ca,bo);
        Cat mic = new Cat("mic");
        Fish fi = new Fish("fi");
        tom.feed(mic,fi);


多态：提高代码复用性


p307 多态基本介绍

多态是指方法或对象有多种形态，建立在封装和继承的基础上

具体体现：
1.方法多态：
    重写和重载
    
    
p308  对象多态
对象的多态：
    1.一个对象的编译类型和运行类型可以不一致
        Animal animal = new Dog(); 【animal编译类是Animal，运行类是Dog】子类对象（dog可以赋给父类引用（animal
    2.编译类型由定义对象确定，不能改变
        Animal animal        Animal类的对象引用
    3.运行类型可以改变
        animal = new Cat();  指向Cat类的对象空间
    4.编译类型 = 运行类型
    
多态对程序的影响
        Animal animal = new Dog();
        animal.cry();   //执行到这里时 animal运行类型是dog，所以是dog的cry（）
        animal = new Cat();
        animal.cry();   //运行类型为Cat，Cat的cry()
        animal = new Fish();
        animal.cry();   //运行类型是Fish，Fish cannot cry
        
        
 p309 多态入门
 
 主人喂食问题：
 MAster：
    //使用多态机制，统一管理喂食
    //animal 可以指向Animal子类的对象
    //food 也可以指向Food子类的对象
    public void feed(Animal animal, Food food){
        System.out.println("master " + name + " feed " + animal.getName()
                +" with " + food.getName());
    }
 main:
        Master tom = new Master("tom");
        Cat ca = new Cat("ca");
        Bone bo = new Bone("bo");
        tom.feed(ca,bo);
        Cat mic = new Cat("mic");
        Fish fi = new Fish("fi");
        tom.feed(mic,fi);
        Pig pp = new Pig("pp");
        Rice rice = new Rice("rice");
        tom.feed(pp,rice);
 


p310 多态细节
前提：类存在继承关系
向上转型：父类指向子类对象  
    父类 引用名 = new 子类
    Animal animal = new Cat();
特点：
可以调用父类所有成员（访问权限需要遵守），
不能调用子类特有成员
    animal可以调用Animal的方法（eat，run，。。
    但不能调用Cat的特有方法（抓老鼠。。
  
  
























































